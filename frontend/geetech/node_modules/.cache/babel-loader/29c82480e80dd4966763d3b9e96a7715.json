{"ast":null,"code":"import { TinyColor } from '@ctrl/tinycolor';\n\nfunction tinycolor(...args) {\n  return new TinyColor(...args);\n}\n\nfunction _colorChange(data, oldHue) {\n  const alpha = data && data.a;\n  let color; // hsl is better than hex between conversions\n\n  if (data && data.hsl) {\n    color = tinycolor(data.hsl);\n  } else if (data && data.hex && data.hex.length > 0) {\n    color = tinycolor(data.hex);\n  } else if (data && data.hsv) {\n    color = tinycolor(data.hsv);\n  } else if (data && data.rgba) {\n    color = tinycolor(data.rgba);\n  } else if (data && data.rgb) {\n    color = tinycolor(data.rgb);\n  } else {\n    color = tinycolor(data);\n  }\n\n  if (color && (color._a === undefined || color._a === null)) {\n    color.setAlpha(alpha || color.getAlpha());\n  }\n\n  const hsl = color.toHsl();\n  const hsv = color.toHsv();\n\n  if (hsl.s === 0) {\n    hsv.h = hsl.h = data.h || data.hsl && data.hsl.h || oldHue || 0;\n  }\n  /* --- comment this block to fix #109, may cause #25 again --- */\n  // when the hsv.v is less than 0.0164 (base on test)\n  // because of possible loss of precision\n  // the result of hue and saturation would be miscalculated\n  // if (hsv.v < 0.0164) {\n  //   hsv.h = data.h || (data.hsv && data.hsv.h) || 0\n  //   hsv.s = data.s || (data.hsv && data.hsv.s) || 0\n  // }\n  // if (hsl.l < 0.01) {\n  //   hsl.h = data.h || (data.hsl && data.hsl.h) || 0\n  //   hsl.s = data.s || (data.hsl && data.hsl.s) || 0\n  // }\n\n  /* ------ */\n\n\n  return {\n    hsl,\n    hex: color.toHexString().toUpperCase(),\n    hex8: color.toHex8String().toUpperCase(),\n    rgba: color.toRgb(),\n    hsv,\n    oldHue: data.h || oldHue || hsl.h,\n    source: data.source,\n    a: color.getAlpha()\n  };\n}\n\nvar colorMixin = {\n  model: {\n    prop: 'modelValue',\n    event: 'update:modelValue'\n  },\n  props: ['modelValue'],\n\n  data() {\n    return {\n      val: _colorChange(this.modelValue)\n    };\n  },\n\n  computed: {\n    colors: {\n      get() {\n        return this.val;\n      },\n\n      set(newVal) {\n        this.val = newVal;\n        this.$emit('update:modelValue', newVal);\n      }\n\n    }\n  },\n  watch: {\n    modelValue(newVal) {\n      this.val = _colorChange(newVal);\n    }\n\n  },\n  methods: {\n    colorChange(data, oldHue) {\n      this.oldHue = this.colors.hsl.h;\n      this.colors = _colorChange(data, oldHue || this.oldHue);\n    },\n\n    isValidHex(hex) {\n      return tinycolor(hex).isValid;\n    },\n\n    simpleCheckForValidColor(data) {\n      const keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];\n      let checked = 0;\n      let passed = 0;\n\n      for (let i = 0; i < keysToCheck.length; i++) {\n        const letter = keysToCheck[i];\n\n        if (data[letter]) {\n          checked++;\n\n          if (!isNaN(data[letter])) {\n            passed++;\n          }\n        }\n      }\n\n      if (checked === passed) {\n        return data;\n      }\n    },\n\n    paletteUpperCase(palette) {\n      return palette.map(c => c.toUpperCase());\n    },\n\n    isTransparent(color) {\n      return tinycolor(color).getAlpha() === 0;\n    }\n\n  }\n};\nexport { colorMixin as default };","map":{"version":3,"sources":["/home/neuromancer/projects/YodaTeam/frontend/geetech/node_modules/@ckpack/vue-color/libs/mixin/color.js"],"names":["TinyColor","tinycolor","args","_colorChange","data","oldHue","alpha","a","color","hsl","hex","length","hsv","rgba","rgb","_a","undefined","setAlpha","getAlpha","toHsl","toHsv","s","h","toHexString","toUpperCase","hex8","toHex8String","toRgb","source","colorMixin","model","prop","event","props","val","modelValue","computed","colors","get","set","newVal","$emit","watch","methods","colorChange","isValidHex","isValid","simpleCheckForValidColor","keysToCheck","checked","passed","i","letter","isNaN","paletteUpperCase","palette","map","c","isTransparent","default"],"mappings":"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","sourcesContent":["import { TinyColor } from '@ctrl/tinycolor';\n\nfunction tinycolor(...args) {\n  return new TinyColor(...args);\n}\n\nfunction _colorChange(data, oldHue) {\n  const alpha = data && data.a;\n  let color;\n\n  // hsl is better than hex between conversions\n  if (data && data.hsl) {\n    color = tinycolor(data.hsl);\n  } else if (data && data.hex && data.hex.length > 0) {\n    color = tinycolor(data.hex);\n  } else if (data && data.hsv) {\n    color = tinycolor(data.hsv);\n  } else if (data && data.rgba) {\n    color = tinycolor(data.rgba);\n  } else if (data && data.rgb) {\n    color = tinycolor(data.rgb);\n  } else {\n    color = tinycolor(data);\n  }\n\n  if (color && (color._a === undefined || color._a === null)) {\n    color.setAlpha(alpha || color.getAlpha());\n  }\n\n  const hsl = color.toHsl();\n  const hsv = color.toHsv();\n\n  if (hsl.s === 0) {\n    hsv.h = hsl.h = data.h || (data.hsl && data.hsl.h) || oldHue || 0;\n  }\n\n  /* --- comment this block to fix #109, may cause #25 again --- */\n  // when the hsv.v is less than 0.0164 (base on test)\n  // because of possible loss of precision\n  // the result of hue and saturation would be miscalculated\n  // if (hsv.v < 0.0164) {\n  //   hsv.h = data.h || (data.hsv && data.hsv.h) || 0\n  //   hsv.s = data.s || (data.hsv && data.hsv.s) || 0\n  // }\n\n  // if (hsl.l < 0.01) {\n  //   hsl.h = data.h || (data.hsl && data.hsl.h) || 0\n  //   hsl.s = data.s || (data.hsl && data.hsl.s) || 0\n  // }\n  /* ------ */\n\n  return {\n    hsl,\n    hex: color.toHexString().toUpperCase(),\n    hex8: color.toHex8String().toUpperCase(),\n    rgba: color.toRgb(),\n    hsv,\n    oldHue: data.h || oldHue || hsl.h,\n    source: data.source,\n    a: color.getAlpha(),\n  };\n}\n\nvar colorMixin = {\n  model: {\n    prop: 'modelValue',\n    event: 'update:modelValue',\n  },\n  props: ['modelValue'],\n  data() {\n    return {\n      val: _colorChange(this.modelValue),\n    };\n  },\n  computed: {\n    colors: {\n      get() {\n        return this.val;\n      },\n      set(newVal) {\n        this.val = newVal;\n        this.$emit('update:modelValue', newVal);\n      },\n    },\n  },\n  watch: {\n    modelValue(newVal) {\n      this.val = _colorChange(newVal);\n    },\n  },\n  methods: {\n    colorChange(data, oldHue) {\n      this.oldHue = this.colors.hsl.h;\n      this.colors = _colorChange(data, oldHue || this.oldHue);\n    },\n    isValidHex(hex) {\n      return tinycolor(hex).isValid;\n    },\n    simpleCheckForValidColor(data) {\n      const keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'l', 'v'];\n      let checked = 0;\n      let passed = 0;\n\n      for (let i = 0; i < keysToCheck.length; i++) {\n        const letter = keysToCheck[i];\n        if (data[letter]) {\n          checked++;\n          if (!isNaN(data[letter])) {\n            passed++;\n          }\n        }\n      }\n\n      if (checked === passed) {\n        return data;\n      }\n    },\n    paletteUpperCase(palette) {\n      return palette.map((c) => c.toUpperCase());\n    },\n    isTransparent(color) {\n      return tinycolor(color).getAlpha() === 0;\n    },\n  },\n};\n\nexport { colorMixin as default };\n"]},"metadata":{},"sourceType":"module"}