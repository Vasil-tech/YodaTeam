{"ast":null,"code":"require(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst wasm = require(\"./tolw\");\n\nfunction writeBufferIntoWasmMemory(heap8, address, data) {\n  // array view input\n  // might be a sub-view, so use byteOffset\n  if (ArrayBuffer.isView(data)) {\n    let {\n      byteOffset,\n      byteLength\n    } = data;\n    heap8.set(new Uint8Array(data.buffer).subarray(byteOffset, byteOffset + byteLength), address); // normal arraybuffer input\n  } else {\n    heap8.set(new Uint8Array(data), address);\n  }\n}\n\n; // ignore emscripten's stupid global exception listener\n\nprocess.removeAllListeners(\"uncaughtException\");\nlet loaded = false;\n\nmodule.exports.init = function () {\n  if (loaded) throw `Wasm module already initialized!`;\n  return new Promise(resolve => {\n    wasm.onRuntimeInitialized = _ => {\n      api = {\n        loadObj: wasm.cwrap(\"loadObj\", \"number\", [\"number\", \"number\"]),\n        freeMemoryAddr: wasm.cwrap(\"freeMemoryAddr\", \"undefined\", [\"number\"])\n      };\n      loaded = true; // tell user we're ready\n\n      resolve(true);\n    };\n  });\n};\n\nmodule.exports.loadObj = function (data) {\n  if (!loaded) throw new Error(\"TOLW isn't initialized!\");\n\n  if (!ArrayBuffer.isView(data) && !(data instanceof ArrayBuffer)) {\n    throw new TypeError(`Input data must be either of type 'ArrayBuffer' or 'ArrayBufferView'`);\n  }\n\n  let addr = wasm._malloc(data.byteLength); // write file into wasm memory\n\n\n  writeBufferIntoWasmMemory(wasm.HEAP8, addr, data); // parse obj\n\n  let memAddr = api.loadObj(addr, data.byteLength);\n  if (!memAddr) throw `Failed to load object file!`; // free file from wasm memory\n\n  wasm._free(addr); // read MemoryAddr struct from heap\n\n\n  let memoryAddrStructSize = 16;\n  let memoryAddrView = wasm.HEAPU32.subarray(memAddr >> 2, (memAddr >> 2) + memoryAddrStructSize);\n  let lengths = memoryAddrView.subarray(4, 4 + 4); // to know how much data we have to reflect per-member\n\n  let offset = 0x0; // create view on vertices\n\n  let verticesPtr = wasm.HEAPU32[memoryAddrView[offset] >> 2]; // deref\n\n  let verticesView = wasm.HEAPF32.subarray(verticesPtr >> 2, (verticesPtr >> 2) + lengths[offset]);\n  offset++; // create view on normals\n\n  let normalsPtr = wasm.HEAPU32[memoryAddrView[offset] >> 2]; // deref\n\n  let normalsView = wasm.HEAPF32.subarray(normalsPtr >> 2, (normalsPtr >> 2) + lengths[offset]);\n  offset++; // create view on uvs\n\n  let uvsPtr = wasm.HEAPU32[memoryAddrView[offset] >> 2]; // deref\n\n  let uvsView = wasm.HEAPF32.subarray(uvsPtr >> 2, (uvsPtr >> 2) + lengths[offset]);\n  offset++; // create view on indices\n\n  let indicesPtr = wasm.HEAPU32[memoryAddrView[offset] >> 2]; // deref\n\n  let indicesView = wasm.HEAPU32.subarray(indicesPtr >> 2, (indicesPtr >> 2) + lengths[offset]);\n  offset++;\n  let out = {\n    vertices: new Float32Array(verticesView),\n    normals: new Float32Array(normalsView),\n    uvs: new Float32Array(uvsView),\n    indices: new Uint32Array(indicesView)\n  }; // free memory addr struct\n  // we used this struct to make processed\n  // object data visisble to js\n\n  api.freeMemoryAddr(memAddr);\n  return out;\n};","map":{"version":3,"sources":["/home/neuromancer/projects/YodaTeam/frontend/geetech/node_modules/tolw/index.js"],"names":["wasm","require","writeBufferIntoWasmMemory","heap8","address","data","ArrayBuffer","isView","byteOffset","byteLength","set","Uint8Array","buffer","subarray","process","removeAllListeners","loaded","module","exports","init","Promise","resolve","onRuntimeInitialized","_","api","loadObj","cwrap","freeMemoryAddr","Error","TypeError","addr","_malloc","HEAP8","memAddr","_free","memoryAddrStructSize","memoryAddrView","HEAPU32","lengths","offset","verticesPtr","verticesView","HEAPF32","normalsPtr","normalsView","uvsPtr","uvsView","indicesPtr","indicesView","out","vertices","Float32Array","normals","uvs","indices","Uint32Array"],"mappings":"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","sourcesContent":["const wasm = require(\"./tolw\");\r\n\r\nfunction writeBufferIntoWasmMemory(heap8, address, data) {\r\n  // array view input\r\n  // might be a sub-view, so use byteOffset\r\n  if (ArrayBuffer.isView(data)) {\r\n    let {byteOffset, byteLength} = data;\r\n    heap8.set(new Uint8Array(data.buffer).subarray(byteOffset, byteOffset + byteLength), address);\r\n  // normal arraybuffer input\r\n  } else {\r\n    heap8.set(new Uint8Array(data), address);\r\n  }\r\n};\r\n\r\n// ignore emscripten's stupid global exception listener\r\nprocess.removeAllListeners(\"uncaughtException\");\r\n\r\nlet loaded = false;\r\nmodule.exports.init = function() {\r\n  if (loaded) throw `Wasm module already initialized!`;\r\n  return new Promise(resolve => {\r\n    wasm.onRuntimeInitialized = _ => {\r\n      api = {\r\n        loadObj: wasm.cwrap(\"loadObj\", \"number\", [\"number\", \"number\"]),\r\n        freeMemoryAddr: wasm.cwrap(\"freeMemoryAddr\", \"undefined\", [\"number\"])\r\n      };\r\n      loaded = true;\r\n      // tell user we're ready\r\n      resolve(true);\r\n    };\r\n  });\r\n};\r\n\r\nmodule.exports.loadObj = function(data) {\r\n  if (!loaded) throw new Error(\"TOLW isn't initialized!\");\r\n\r\n  if (!ArrayBuffer.isView(data) && !(data instanceof ArrayBuffer)) {\r\n    throw new TypeError(`Input data must be either of type 'ArrayBuffer' or 'ArrayBufferView'`);\r\n  }\r\n\r\n  let addr = wasm._malloc(data.byteLength);\r\n\r\n  // write file into wasm memory\r\n  writeBufferIntoWasmMemory(wasm.HEAP8, addr, data);\r\n\r\n  // parse obj\r\n  let memAddr = api.loadObj(addr, data.byteLength);\r\n  if (!memAddr) throw `Failed to load object file!`;\r\n\r\n  // free file from wasm memory\r\n  wasm._free(addr);\r\n\r\n  // read MemoryAddr struct from heap\r\n  let memoryAddrStructSize = 16;\r\n  let memoryAddrView = wasm.HEAPU32.subarray(memAddr >> 2, (memAddr >> 2) + memoryAddrStructSize);\r\n  let lengths = memoryAddrView.subarray(4, 4 + 4); // to know how much data we have to reflect per-member\r\n\r\n  let offset = 0x0;\r\n\r\n  // create view on vertices\r\n  let verticesPtr = wasm.HEAPU32[(memoryAddrView[offset] >> 2)]; // deref\r\n  let verticesView = wasm.HEAPF32.subarray(\r\n    (verticesPtr >> 2),\r\n    (verticesPtr >> 2) + lengths[offset]\r\n  );\r\n\r\n  offset++;\r\n\r\n  // create view on normals\r\n  let normalsPtr = wasm.HEAPU32[(memoryAddrView[offset] >> 2)]; // deref\r\n  let normalsView = wasm.HEAPF32.subarray(\r\n    (normalsPtr >> 2),\r\n    (normalsPtr >> 2) + lengths[offset]\r\n  );\r\n\r\n  offset++;\r\n\r\n  // create view on uvs\r\n  let uvsPtr = wasm.HEAPU32[(memoryAddrView[offset] >> 2)]; // deref\r\n  let uvsView = wasm.HEAPF32.subarray(\r\n    (uvsPtr >> 2),\r\n    (uvsPtr >> 2) + lengths[offset]\r\n  );\r\n\r\n  offset++;\r\n\r\n  // create view on indices\r\n  let indicesPtr = wasm.HEAPU32[(memoryAddrView[offset] >> 2)]; // deref\r\n  let indicesView = wasm.HEAPU32.subarray(\r\n    (indicesPtr >> 2),\r\n    (indicesPtr >> 2) + lengths[offset]\r\n  );\r\n\r\n  offset++;\r\n\r\n  let out = {\r\n    vertices: new Float32Array(verticesView),\r\n    normals: new Float32Array(normalsView),\r\n    uvs: new Float32Array(uvsView),\r\n    indices: new Uint32Array(indicesView)\r\n  };\r\n\r\n  // free memory addr struct\r\n  // we used this struct to make processed\r\n  // object data visisble to js\r\n  api.freeMemoryAddr(memAddr);\r\n\r\n  return out;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}